grammar gram;
SEMI : ';';
WHITESPACE : ( ' ' | '\t' | '\n' | '\r' )+ -> skip;
COMMENT : ('//' (~[\n])* | '/*' .*? '*/') -> skip;
WHILE : 'while';
LP : [(];
RP : [)];
IF : 'if';
ELSE : 'else';
RETURN : 'return';
LBR : [{];
RBR : [}];
MINUS : '-';
NUM : [0-9]+ ;
OR : 'or';
AND : 'and';
NOT : 'not';
RELOP : '>='|'<='|'>'|'<'|'!='|'==';
PLUS : [+];
MULOP : [*/%];
EQ: [=];
TYPE : ('int'|'string'|'double'|'void');
STRING_CONSTANT : '"' ( '\\"' | ~["] )* '"';
PRINT : 'print';
INPUT : 'input';
OPEN : 'open';
READ : 'read';
WRITE : 'write';
CLOSE : 'close';
NOW : 'now';
CMA : ',';
ID : ([A-Za-z_])([A-Za-z0-9_])*;

start : program;
program : decl_list;
decl_list : func_decl decl_list | var_decl SEMI decl_list | ;
func_decl : TYPE ID LP optional_param_list RP braceblock;
optional_param_list : ;
optional_expr_list : ;
var_decl : TYPE ID;
stmts : stmt stmts | ;
stmt : cond | loop | return_stmt SEMI | assign SEMI | func_call SEMI | return_stmt SEMI;
func_call : ID LP optional_expr_list RP | builtin_func_call;
builtin_func_call : PRINT LP expr RP | INPUT LP RP | OPEN LP expr RP | READ LP expr RP | WRITE LP expr CMA expr RP | CLOSE LP expr RP | NOW LP RP;
assign : ID EQ expr;
cond : IF LP expr RP braceblock | IF LP expr RP braceblock ELSE braceblock;
braceblock : LBR stmts RBR;
expr : orexp;
orexp : orexp OR andexp | andexp;
andexp : andexp AND notexp | notexp;
notexp : NOT notexp | rel;
rel : sum RELOP sum | sum;
sum : sum PLUS term | sum MINUS term | term;
term : term MULOP neg | neg;
neg : MINUS neg | factor;
factor : NUM | LP expr RP | ID | STRING_CONSTANT | func_call;
return_stmt : RETURN expr | RETURN;
loop : WHILE LP expr RP braceblock;